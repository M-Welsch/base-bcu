from pathlib import Path
from test.utils.backup_environment.virtual_backup_environment import BackupTestEnvironment, BackupTestEnvironmentOutput
from test.utils.patch_config import patch_config, patch_multiple_configs
from typing import Generator

import pytest

import base.logic.backup.source
from base.logic.backup.backup import Backup
from base.logic.backup.protocol import Protocol


def finished(*args, **kwargs):  # type: ignore
    pass


@pytest.fixture(scope="class")
def backup_environment() -> Generator[BackupTestEnvironment, None, None]:
    with BackupTestEnvironment(
        protocol=Protocol.NFS,
    ) as backup_environment:
        yield backup_environment


class TestBackup:
    @staticmethod
    def test_backup(backup_environment: BackupTestEnvironment) -> None:
        backup_environment.prepare_sink()
        backup_environment.prepare_source(
            amount_files_in_source=10,
            bytesize_of_each_sourcefile=1024,
        )
        patch_config(base.logic.backup.source.BackupSource, backup_environment.sync_config)
        patch_config(base.logic.backup.target.BackupTarget, backup_environment.sync_config)
        patch_config(base.logic.nas.Nas, backup_environment.nas_config)
        patch_multiple_configs(
            base.logic.backup.synchronisation.rsync_command.RsyncCommand,
            {"sync.json": backup_environment.sync_config, "nas.json": backup_environment.nas_config},
        )
        backup = Backup(on_backup_finished=finished)

        assert isinstance(backup.source, Path)
        assert isinstance(backup.target, Path)
        assert backup.source.exists()
        assert not backup.target.exists()  # the target directory will be generated by the backup preparator
        # since the actual target directory won't be available before docking
