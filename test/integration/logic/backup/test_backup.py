from pathlib import Path
from test.utils.backup_environment.virtual_backup_environment import BackupTestEnvironment, BackupTestEnvironmentOutput
from test.utils.patch_config import patch_config, patch_multiple_configs
from typing import Generator

import pytest

import base.logic.backup.source
from base.logic.backup.backup import Backup
from base.logic.backup.protocol import Protocol


def finished(*args, **kwargs):  # type: ignore
    pass


@pytest.fixture
def backup_environment() -> Generator[BackupTestEnvironmentOutput, None, None]:
    bu_env = BackupTestEnvironment(
        protocol=Protocol.NFS,
        use_virtual_drive_for_sink=True,
        amount_old_backups=0,
        bytesize_of_each_old_backup=0,
        amount_preexisting_source_files_in_latest_backup=0,
    )
    bu_env_output = bu_env.create()
    bu_env.create_testfiles(
        amount_files_in_source=10,
        bytesize_of_each_sourcefile=1024,
    )
    yield bu_env_output


@pytest.fixture
def backup(backup_environment: BackupTestEnvironmentOutput) -> Generator[Backup, None, None]:
    patch_config(base.logic.backup.source.BackupSource, backup_environment.sync_config)
    patch_config(base.logic.backup.target.BackupTarget, backup_environment.sync_config)
    patch_config(base.logic.nas.Nas, backup_environment.nas_config)
    patch_multiple_configs(
        base.logic.backup.synchronisation.rsync_command.RsyncCommand,
        {"sync.json": backup_environment.sync_config, "nas.json": backup_environment.nas_config},
    )
    yield Backup(on_backup_finished=finished)


def test_backup(backup: Backup) -> None:
    assert isinstance(backup.source, Path)
    assert isinstance(backup.target, Path)
    assert backup.source.exists()
    assert not backup.target.exists()  # the target directory will be generated by the backup preparator
    # since the actual target directory won't be available before docking
